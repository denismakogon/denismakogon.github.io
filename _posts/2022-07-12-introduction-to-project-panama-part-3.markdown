---
layout: post
title:  'Introduction to Project Panama. Part 3: Code tools.'
#date:   2022-06-8
categories: openjdk panama codetools
tags: ["openjdk", "panama", "jextract"]
image_src_url: 'https://unsplash.com/photos/Wiwqd_8Rds8/download?ixid=MnwxMjA3fDB8MXxzZWFyY2h8OXx8cGFuYW1hfGVufDB8fHx8MTY1NDMyNzMwMg&force=true&w=800'
excerpt: 'This article covers the first external OpenJDK code tool "jextract" that is not a part of OpenJDK distribution!'
---

![Panama]({{ '../images/openjdk-panama/luis-gonzalez-Wiwqd_8Rds8-unsplash.jpg' | relative_url }})
Photo by [Luis Gonzalez](https://unsplash.com/@luchox23?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
on [Unsplash](https://unsplash.com/s/photos/panama?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)

## Introduction

As mentioned in [Part 1]({{ '/openjdk/panama/2022/05/31/introduction-to-project-panama-part-1.html' | relative_url }}), Project Panama consists of 3 components:
* The Foreign Function & Memory API: [JEP 424](https://openjdk.java.net/jeps/424)
* The [Jextract tool](https://github.com/openjdk/jextract)
* The Vector API: [JEP 338](https://openjdk.java.net/jeps/338)

Both Part 1 and Part 2 ([2.1]() & [2.2]()) were focused on the Foreign Function and Memory API -- building blocks of the C ABI implementation in Java.
In this article I'd like to showcase a new OpenJDK code tool -- `jextract`. Curious fact that it is the first one component of the JDK that is not shipped as part of a binary archive.

## JNI

Every application contains many bits of software developed as a standalone solutions, like software libraries.
Even a simple "Hello World" application depends on a programming language standard library (exists in every programming language) and eventually on the C standard library.

But the most important feature of the programming language is the direct access to a native code (other libraries). So, for the long time, Java developers who work with 
a native code had to use the "Java Native Interface" (JNI). It is a framework that lets the JVM to call (downcalls) and to be called (upcalls) by native code.

This framework enables software developers to write native methods to handle situations when an application cannot be written entirely in the Java, 
or when the standard Java library does not support the platform-specific features or a software library.

Think of JNI not like it's just a framework, but also it also implies to a [procedure](https://www.protechtraining.com/blog/post/java-native-interface-jni-example-65) that JNI consumers must follow in order to implement both downcalls and upcalls.
The main idea is that most of the software development is done using C programming language:
```java
public native void sayHi(String who, int times);
```

```cpp
#include <stdio.h> 
#include "Hello.h"	// generated by javah

JNIEXPORT void JNICALL Java_Hello_sayHi 
(JNIEnv *env, jobject obj, jstring who, jint times) { 
	jint i; 
	jboolean iscopy; 
	const char *name; 
	name = (*env)->GetStringUTFChars(env, who, &iscopy); 
	for (i = 0; i < times; i++) {
		printf("Hello %s\n", name);
	}
}
```

Most developers claimed that the JNI is "slow" due to [multiple reasons](https://stackoverflow.com/questions/7699020/what-makes-jni-calls-slow/7809300#7809300).
The reason for such claims hidden in the nature of JNI development process. As I said before, 
most of the development is done in C and compiled into a library, which means it can not be optimized by the JVM.
So, the JNI had the downsides like any other framework or an SDK, it didn't gain a lot of popularity, that's why a few other community initiates appeared. 

So, eventually, the JDK developers wanted to introduce better solution comparing to the JNI, 
and they did -- Project Panama have introduced Foreign Function and Memory API that will replace the JNI eventually.


## A new member of OpenJDK code tools

Similarly to the JNI that relied on the `javah` code tool, Project Panama introduced a new code tool -- [jextact](https://github.com/openjdk/jextract).
While `javah` used to create C and header (`*.h`) files, `jextract` does the opposite -- it generates Java bindings to the native code.

The purpose of `jextract` is to take off the responsibility from developers by generating Java classes for the native methods and data structures with the respect to a header file passed to it.

Interesting fact, `jextract` is the first code tool that is a part of the OpenJDK but not a part of the distribution like any other JDK CLI tools.
Basically, the `jextract` is a standalone project and a deliverable of the Project Panama under the OpenJDK umbrella. 

There are a few reasons why it's not a part of the JDK distribution. First, not all Java developers are the JNI consumers, i.e., not all developers use `javah`, so the `jextract` is not for everyone.
The second and probably the most critical reason -- it's HUGE. Normally, size of the JDK is somewhat around 360Mb, the `jextract` adds on top around 177Mb.

It is that big because `jextract` is not a typical tool that depends on the JDK classes, it is more than that. 
The `jextract` depends on:
* the JDK 19 or greater (Foreign Function & Memory API, in particular), 360Mb,
* [libclang](https://github.com/llvm/llvm-project) -- C interface to the CLang, 560Mb.

So, `jextract` uses libclang to parsea a header file (into methods, their types, data structures and so on) and Foreign Function & Memory API to model CLang objects in Java, plus adding a few more helper classes to the list of generated sources.

## Obtaining `jextract` binary

`jextract` is the first OpenJDK tool that is not a part of the distribution. A binary releases will be available at the [GitHub](https://github.com/openjdk/jextract/releases), a release schedule will follow the OpenJDK release timelines (each 6 months).
At the moment of writing there are no binary releases yet, it's important to build one from source code.

### Compiling from sources

`jextract` supports all popular platforms like Linux, macOS, Windows. But this part of an article will focus on building and using the `jextract` binary within a Docker container to make it easier to reproduce on any type of container engine implementations (Docker, Podman, etc.).

To build a container containing the `jextract` binary, create a `Containerfile` with the following content:
```dockerfile
FROM openjdk:19-bullseye as jdk19-source
FROM openjdk:18-bullseye as jextract-build-stage

COPY --from=jdk19-source /usr/local/openjdk-19 /usr/local/openjdk-19

WORKDIR tmp/
RUN apt-get update && apt-get install wget tar xz-utils git -qy --no-install-recommends
RUN mkdir deps && \
    wget -O deps/LLVM.tar.gz https://github.com/llvm/llvm-project/releases/download/llvmorg-14.0.4/clang+llvm-14.0.4-x86_64-linux-gnu-ubuntu-20.04.tar.xz && \
    tar -xvf deps/LLVM.tar.gz -C deps && rm -fr deps/LLVM.tar.gz && \
    git clone https://github.com/openjdk/jextract.git && \
    cd jextract && \
    sh ./gradlew -Pjdk19_home=/usr/local/openjdk-19 -Pllvm_home=../deps/clang+llvm-14.0.4-x86_64-linux-gnu-ubuntu-20.04 clean verify && \
    rm -fr /tmp/deps

FROM openjdk:19-bullseye as jdk19-custom-runtime

COPY --from=jextract-build-stage /tmp/jextract/build/jextract/ /usr/local/jextract
ENV PATH=${PATH}:/usr/local/jextract/bin
```

Build a container image:
```shell
docker build -t jextract -f Containerfile .
```

Please note that the `jextract` is a developer tool, therefore it's not needed at the runtime to save some space.

### Validating the binary

Please ensure that the `jextract` is working properly:
```shell
docker run --rm -ti jextract jextract --version
```
```shell
jextract 19-ea
JDK version 19-ea+24-1832
clang version 14.0.4
```

## Generating source codes for C _printf_

Previous articles have shown how to implement a method handle for the C _printf_ manually, i.e., how to create a linker, a symbol lookup, a function descriptor.
The purpose of the `jextract` to take the responsibility of creating necessary components for both downcalls and upcalls.

In order to make code generation successful the `jextarct` must know where a header file resides.

### Searching for header files

If you aren't sure where to look for header files, use the following command:
```shell
echo | gcc -E -Wp,-v -
```
one of folders may contain the required header file:
```shell
...
 /usr/lib/gcc/x86_64-linux-gnu/10/include
 /usr/local/include
 /usr/include/x86_64-linux-gnu
 /usr/include
End of search list.
...
```

The `gcc` will prompt a list of the default system paths where the compiler look for system header files. 
Considering that the `stdio.h` is a part of the C standard library header file must exist within of one those folders:
```shell
ls -lah /usr/include/stdio.h
```

### Generating Java classes from a header file

The main goal of the `jextract` is to shorten the path between finding a header file and calling a native function from Java runtime.  
So, the experience implementing the C _printf_ earned in previous articles may be dramatically changed in a positive direction.

To generate Java classes that represent the C `stdio.h` the `jextract` must be provided with a target Java package, the output folder and a path to a header file:
```shell
jextract \
  --source -t "com.java_devrel.samples.stdlib.stdio" \
  -I "/usr/include" "/usr/include/stdio.h" \
  --output src/main/java
```

The `jextract` will create the following code structure:
```shell
src/main/java/com/java_devrel/samples/stdlib/stdio/
...
├── RuntimeHelper.java
...
├── constants$17.java
...
└── stdio_h.java

0 directories, 48 files
```

As a result, a newly created package will contain a few types of Java classes. First and the most important one is the API class (`stdio_h.java`) -- a Java representation of a header file, it consists of constants, data structs and functions mentioned in a header file.
While the rest of Java classes (like `constants$<number>.java`) hold static objects (constants, descriptors, method handles and so on), the `RuntimeHelpler.java` is a class contain necessary components to perform both upcalls and downcalls as well as variadic function handler. 
There are still left a few types of classes, but it's not relevant for this article.

### Exploring generated Java classes

Please keep in mind, there is only one public API class in a package (in the case of the C stdio -- `stdio_h.java`). This API class contains only "extractable" objects. 
There also could be more public classes, they may contain a memory layouts of data structs if a header file has them.

If a header file contain "too many" native functions then it's possible that the `jextract` will divide generated sources into multiple API classes connected to each other through the inheritance, but the still there would be only one public API class.

Unfortunately, a function-like macros 
```c
#define av_err2str(errnum) \
    av_make_error_string((char[AV_ERROR_MAX_STRING_SIZE]){0}, AV_ERROR_MAX_STRING_SIZE, errnum)
```
are not exportable because they don't have a native symbol compared to constants, functions and data structures, 
so the `jextract` will not create a method handle for it.

In addition to macros, not all functions, constants and structs can be exported due to lack of data types support, i.e., `long double` is not present in Java. 
When [Project Valhalla](https://openjdk.java.net/projects/valhalla/) will be available, Panama will benefit from it by improving .

### Exploring С _printf_ Java components

While generated sources contain a unique representation of a **FunctionDescriptor**, **MemorySegment** and **MethodHandle** for every native function, 
the invocation infrastructure (**SymbolLookup** and a **Linker**) shared through generated classes:
```java
    static {
        SymbolLookup loaderLookup = SymbolLookup.loaderLookup();
        SYMBOL_LOOKUP = name -> loaderLookup.lookup(name).or(() -> LINKER.defaultLookup().lookup(name));
    }
```

So, for the C _printf_ `jextract` will create the following components:

* a function descriptor covering a return value and named arg layouts only, no variadic args (see [why-2.2]()):
```java
    static final FunctionDescriptor printf$FUNC = 
        FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
```

* a native address and a method handle:
```java
    static final MethodHandle printf$MH = 
        RuntimeHelper.downcallHandleVariadic(
            "printf",
            constants$4.printf$FUNC
    );
```

* C-like Java signature method (a wrapper around a method handle invocation):
```java
    public static int printf ( Addressable x0, Object... x1) {
        var mh$ = printf$MH();
        try {
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
```

So, the `jextract` purpose as code generating tool to simplify the development process, by making developers be responsible only for the memory management (CRUD operations).

With the generated Java classes the amount of code necessary to perform the downcalls to a native function like the C _printf_ have dramatically decreased comparing to a manual declaration shown in the previous articles.
Considering that almost all preparation work was already done (generated) there's nothing much left to call the C _printf_ function using API methods from `stdio_h.java`:
```java
package com.java_devrel.samples.panama.part_3;

import java.lang.foreign.MemorySession;
import java.lang.foreign.SegmentAllocator;

import static com.java_devrel.samples.stdlib.stdio.stdio_h.printf;

public class Printf {
    public static void main(String[] args) {
        try (var memorySession = MemorySession.openConfined()) {
            var allocator = SegmentAllocator.newNativeArena(memorySession);
            var cString = allocator.allocateUtf8String("Welcome from the other side!\n");
            printf(cString);
        }
    }
}
```

As mentioned before, a **MemorySession** is like a combination of the explicit C _malloc_ and an implicit _free_ in one bottle, 
so Java version of C _printf_ invocation isn't really correspond to a simple "Hello World" application, but to more advanced version:
<script style="width: 1px;max-width: 100%;min-width: 100%;overflow: hidden;" src="//onlinegdb.com/embed/js/pD1AGYs6N?theme=dark"></script>

The very first best thing about `jextract` isn't just the amount of code it generates for a library header file,
but the quality of them that provide the ability to preserve or even improve the user experience working
with the native C/C++ code but in Java.


## Treating generated sources

When you played enough with the sources it will be the time to give an answer to the following questions:
1. Whether include into the VCS or not.
Generate on a target host/OS.
